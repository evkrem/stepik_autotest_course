Поиск по css селектору
1. #bullet (знак # означает, что мы ищем атрибут id со значением bullet).
2. чтобы найти элемент по тегу, просто напишите название тега в поисковой строке
3. поиск по значению атрибута ищет точное совпадение: [id="bullet"],  [value="Cat memes"], [name="bullet-cat"], [class="jumbotron-heading"],
4. при нескольких значениях атрибута (class="lead text-muted") найти одно из значений можно .lead или .text-muted. Либо же сразу два .lead.text-muted

Использование потомков
#post2 .title ищет элемент с id="post2", и среди классом со значением "title". Пробел между ними означает, что искать можно на любом уровне вложенности. Без пробела означало бы, что ищем несколько классов в одном атрибуте

Использование дочерних элементов
Другой способ найти этот элемент: #post2 > div.title
Здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент с тегом и классом: "div.title", который находится строго на один уровень иерархии ниже чем элемент "#post2" (это задаёт символ ">")

Использование порядкового номера дочернего элемента
#posts > .item:nth-child(2) > .title
Псевдо-класс :nth-child(2) - позволяет найти второй по порядку элемент среди дочерних элементов для "#posts". Затем с помощью "> .title" мы указываем, что нам нужен элемент ".title", родителем которого является найденный ранее элемент ".item".:;

#melon + p  Это соседний селектор. Он выбирает только тот элемент, который следует сразу же за указанным элементом - т.е. выбираем первый абзац идущий за id melon


Поиск элементов с помощью Selenium
Для поиска элементов на странице в Selenium WebDriver используются несколько стратегий, позволяющих искать по атрибутам элементов, текстам в ссылках, CSS-селекторам и XPath-селекторам. Существуют следующие методы поиска элементов:

find_element_by_id - поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
find_element_by_css_selector - поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
find_element_by_xpath - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
find_element_by_name - поиск по атрибуту name элемента;
find_element_by_tag_name - поиск элемента по названию тега элемента;
find_element_by_class_name - поиск по значению атрибута class;
find_element_by_link_text - поиск ссылки на странице по полному совпадению;
find_element_by_partial_link_text - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.

from selenium.webdriver.common.by import By
button = browser.find_element(By.ID, "submit_button")

By.ID – поиск по уникальному атрибуту id элемента;
By.CSS_SELECTOR – поиск элементов с помощью правил на основе CSS;
By.XPATH – поиск элементов с помощью языка запросов XPath;
By.NAME – поиск по атрибуту name элемента;
By.TAG_NAME – поиск по названию тега;
By.CLASS_NAME – поиск по атрибуту class элемента;
By.LINK_TEXT – поиск ссылки с указанным текстом. Текст ссылки должен быть точным совпадением;
By.PARTIAL_LINK_TEXT – поиск ссылки по частичному совпадению текста.


Работа со списками.
<label for="dropdown">Выберите язык программирования:</label>
<select id="dropdown" class="custom-select">
	<option selected>--</option>
	<option value="1">Python</option>
	<option value="2">Java</option>
	<option value="3">JavaScript</option>
</select>

Метод get_attribute находит атрибут элемента. Если атрибута нет, то метод get_attribute вернёт значение None.
robots_radio = browser.find_element_by_id("robotsRule")
robots_checked = robots_radio.get_attribute("checked")

from selenium.webdriver.support.ui import Select #используется специальный класс Select 
select = Select(browser.find_element_by_tag_name("select"))
select.select_by_value("1") # ищем элемент с текстом "Python"
Можно использовать еще два метода: 
select.select_by_visible_text("text") - ищет элемент по видимому тексту, например, select.select_by_visible_text("Python") найдёт "Python" для нашего примера.
select.select_by_index(index) ищет элемент по его индексу или порядковому номеру. Индексация начинается с нуля. Для того чтобы найти элемент с текстом "Python", нужно использовать select.select_by_index(1), так как опция с индексом 0 в данном примере имеет значение по умолчанию равное "--".

Скроллинг страницы (джаваскрипт) до кнопки button
	button = browser.find_element_by_tag_name("button")
	browser.execute_script("return arguments[0].scrollIntoView(true);", button)  
	
Всплывающие окна
алерт
alert = browser.switch_to.alert
alert.accept()

конфирм
confirm = browser.switch_to.alert
confirm.accept() # согласие
confirm.dismiss() # отказ
	
промт (с полем для ввода текста)
prompt = browser.switch_to.alert
prompt.send_keys("My answer")
prompt.accept()

ПЕРЕКЛЮЧЕНИЕ МЕЖДУ ВКЛАДКАМИ
	new_window = browser.window_handles[1] # запоминаем название второй вкладки
    browser.switch_to.window(new_window)  # переключаемся на нее
    first_window = browser.window_handles[0] # запоминаем название первой вкладки
	browser.switch_to.window(first_window)  # переключаемся на нее

ОЖИДАНИЕ элементов на странице 
browser.implicitly_wait(5)

Маркировка тестов - Для маркировки теста нужно написать декоратор вида @pytest.mark.mark_name, где mark_name - произвольная строка.
Для регистрации метки создайте файл pytest.ini в корневой директории вашего тестового проекта и добавьте в файл следующие строки:
[pytest]
markers =
    smoke: marker for smoke tests
    regression: marker for regression tests
Текст после знака ":" является поясняющим - его можно не писать. 
Так же можно маркировать целый тестовый класс. В этом случае маркировка будет применена ко всем тестовым методам, входящим в класс.

class TestMainPage1():
    @pytest.mark.smoke
    def test_guest_should_see_login_link(self, browser):
        browser.get(link)
        browser.find_element_by_css_selector("#login_link")

    @pytest.mark.regression
    def test_guest_should_see_basket_link_on_the_main_page(self, browser):
        browser.get(link)
        browser.find_element_by_css_selector(".basket-mini .btn-group > a")

Чтобы запустить тест с нужной маркировкой, нужно передать в командной строке параметр -m и нужную метку:
pytest -s -v -m smoke test_fixture8.py

Чтобы запустить все тесты, не имеющие заданную маркировку, можно использовать инверсию. Для запуска всех тестов, не отмеченных как smoke, нужно выполнить команду:
pytest -s -v -m "not smoke" test_fixture8.py

Для запуска тестов с разными метками можно использовать логическое ИЛИ. Запустим smoke и regression-тесты:
pytest -s -v -m "smoke or regression" test_fixture8.py

чтобы пропустить тест, его отмечают в коде как @pytest.mark.skip:


















	
	
	
	